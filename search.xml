<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis-plus集成</title>
      <link href="/2020/06/16/mybatis-plus-ji-cheng/"/>
      <url>/2020/06/16/mybatis-plus-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2><span id="mybatis-升级-mybatis-plus">mybatis 升级 MyBatis-plus</span></h2><p>maven:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--starter 改为 mybatis-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--代码生成器默认引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mybatis.mapper-locations 修改为 mybatis-plus.mapper-locations</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath*:com/jzhao/mybatisplus/**/*Mapper.xml</span></span><br><span class="line"><span class="meta">mybatis-plus.refresh-mapper</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure><h2><span id="自定义id生成器">自定义ID生成器</span></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.ASSIGN_ID)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="逻辑删除">逻辑删除</span></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> String deleted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="自动填充">自动填充</span></h2><p> po配置填充策略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="meta">@TableField</span>(value = <span class="string">"create_time"</span>,fill = FieldFill.INSERT)</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@TableField</span>(value = <span class="string">"update_time"</span>,fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>增加handler</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 一定不要忘记把处理器加到IOC容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>{</span><br><span class="line">    <span class="comment">// 插入时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"start insert fill....."</span>);</span><br><span class="line">        <span class="comment">// setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"createTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"start update fill....."</span>);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="注册乐观锁-分页插件">注册乐观锁、分页插件</span></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.jzhao.mybatisplus.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注解实体字段 <code>@Version</code> 必须要!</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></tbody></table></figure><h2><span id="性能分性插件">性能分性插件</span></h2><p>maven:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 执行 SQL 分析打印 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>增加 spy.properties</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3.2.1以上使用</span></span><br><span class="line"><span class="attr">modulelist</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment">#3.2.1以下使用或者不配置</span></span><br><span class="line"><span class="comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment"># 自定义日志打印</span></span><br><span class="line"><span class="attr">logMessageFormat</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span></span><br><span class="line"><span class="comment">#日志输出到控制台</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span></span><br><span class="line"><span class="comment"># 使用日志系统记录 sql</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span></span><br><span class="line"><span class="comment"># 设置 p6spy driver 代理</span></span><br><span class="line"><span class="attr">deregisterdrivers</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 取消JDBC URL前缀</span></span><br><span class="line"><span class="attr">useprefix</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span></span><br><span class="line"><span class="attr">excludecategories</span>=<span class="string">info,debug,result,commit,resultset</span></span><br><span class="line"><span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">dateformat</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment"># 实际驱动可多个</span></span><br><span class="line"><span class="comment">#driverlist=org.h2.Driver</span></span><br><span class="line"><span class="comment"># 是否开启慢SQL记录</span></span><br><span class="line"><span class="attr">outagedetection</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 慢SQL记录标准 2 秒</span></span><br><span class="line"><span class="attr">outagedetectioninterval</span>=<span class="string">1</span></span><br></pre></td></tr></tbody></table></figure><p>修改 application.properties 中的 spring.datasource.url、spring.datasource.driver-class-name</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据源</span></span><br><span class="line"><span class="meta">jdbc.type</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment">#数据源url</span></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/ntzhsd?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:p6spy:mysql://127.0.0.1:3306/ntzhsd?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="comment">#数据源用户名</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据源密码</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">6262</span></span><br><span class="line"><span class="comment">#数据源驱动</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.p6spy.engine.spy.P6SpyDriver</span></span><br></pre></td></tr></tbody></table></figure><h2><span id="代码生成器">代码生成器</span></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//需要构建一个代码自动生成对象</span></span><br><span class="line">        AutoGenerator autoGenerator = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">//全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">        gc.setOutputDir(projectPath+<span class="string">"/mybatis-plus/src/main/java"</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">"zhao_jx"</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        gc.setFileOverride(<span class="keyword">true</span>);</span><br><span class="line">        gc.setServiceName(<span class="string">"%sService"</span>);<span class="comment">//去掉Service的I前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line">        gc.setBaseColumnList(<span class="keyword">true</span>);</span><br><span class="line">        gc.setBaseResultMap(<span class="keyword">true</span>);</span><br><span class="line">        autoGenerator.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">"jdbc:mysql://127.0.0.1:3306/ntzhsd?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull"</span>);</span><br><span class="line">                dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">"6262"</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        autoGenerator.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、包的配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">"mybatisplus"</span>);</span><br><span class="line">        pc.setParent(<span class="string">"com.jzhao"</span>);</span><br><span class="line">        pc.setEntity(<span class="string">"po"</span>);</span><br><span class="line">        pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">        pc.setService(<span class="string">"service"</span>);</span><br><span class="line">        pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">        autoGenerator.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">"t_whsx_acci"</span>); <span class="comment">// 设置要映射的表名</span></span><br><span class="line">        strategy.setTablePrefix(<span class="string">"t_"</span>);<span class="comment">// 设置要映射的前缀，生成代码时，自动去掉前缀</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// 自动lombok；</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>);</span><br><span class="line">        <span class="comment">// 自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">"gmt_create"</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">"gmt_modified"</span>,</span><br><span class="line">                FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line"><span class="comment">// 乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">//localhost:8080/hello_id_2</span></span><br><span class="line">        autoGenerator.setStrategy(strategy);</span><br><span class="line">        autoGenerator.execute(); <span class="comment">//执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="mapperxml放在src下">Mapper.xml放在src下</span></h2><p>pom 的 build  节点下增加</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>application.properties </p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath*:com/jzhao/mybatisplus/**/*Mapper.xml</span></span><br></pre></td></tr></tbody></table></figure><h2><span id="mapper-locations-配置多个mapper路径">mapper-locations 配置多个mapper路径</span></h2><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath:mappers/push/*.xml,classpath*:/mappers/*.xml</span></span><br></pre></td></tr></tbody></table></figure><h2><span id="idea热布署">idea热布署</span></h2><p>1、安装JRebel and XRebel for IntelliJ、JRebel mbatisPlus extension</p><p>2、激活 JRebel 。参考：<a href="https://www.jianshu.com/p/2627e15d25a1" target="_blank" rel="noopener">https://www.jianshu.com/p/2627e15d25a1</a></p><blockquote><p>主要是获取一个激活码，再随便填个邮箱</p></blockquote><p>3、 开启idea 代码自动编译：Build project automatically</p><p>4、开启idea Registry：compiler.automake.allow.when.app.running</p><p>5、重启  idea , JRebel  运行项目</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MyBatis-plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven_项目的依赖、聚合、继承</title>
      <link href="/2020/05/08/maven-xiang-mu-de-yi-lai-ju-he-ji-cheng/"/>
      <url>/2020/05/08/maven-xiang-mu-de-yi-lai-ju-he-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h1><span id="maven_项目的依赖-聚合-继承"></span></h1><p><strong>一、假设目前有三个maven项目，分别是project.A、project.B、project.C</strong></p><p><strong>要求B依赖A、C依赖B但不依赖C</strong></p><p>1、B添加对A的依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project.A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>A必须先安装到本地库，否则编译B时会抛异常</p><p>A: clean install  B:clean compile</p><p>2、C添加对B的依赖，同时排除对A的依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project.B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project.A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>二、假设目前有四个maven项目，分别是project.parent、project.A、project.B、project.C</strong></p><p><strong>要求A、B、C整合到一个项目，并且从project.parent继承依赖</strong></p><p><strong>1、parent聚合A、B、C三个项目</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../project.A<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../project.B<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../project.C<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>执行clean compile 进行验证，会同时编译A、B、C三个项目</p><p><strong>2、\</strong>A、B、C分别关联parent项目****</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project.parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>会自动继承父类的依赖jar</p><p><img src="https://images2015.cnblogs.com/blog/35158/201606/35158-20160610182651949-1355013356.png" alt="img"></p><p><strong>如果把父类依赖放在中管理，则子类不会自动成父类的依赖</strong></p><p><strong><img src="https://images2015.cnblogs.com/blog/35158/201606/35158-20160610182652996-992154886.png" alt="img"></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MAVEN </category>
          
          <category> maven_项目的依赖、聚合、继承 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven_项目的依赖、聚合、继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax请求跨域，服务端解决方案</title>
      <link href="/2020/04/26/ajax-qing-qiu-kua-yu-fu-wu-duan-jie-jue-fang-an/"/>
      <url>/2020/04/26/ajax-qing-qiu-kua-yu-fu-wu-duan-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h2><span id="ajax跨域访问解决方法再种方法不能同时配置">ajax跨域访问解决方法（再种方法不能同时配置）</span></h2><h3><span id="1-访问的是nginx接口配置方法">1、访问的是nginx接口，配置方法：</span></h3><p>​    在nginx.conf中添加：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /lxtgpt/service/ {</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) {</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8088/lxtgpt/service/;        </span><br><span class="line">    <span class="comment">#proxy_pass http://192.168.136.61:8088/lxtgpt/service/;</span></span><br><span class="line">    <span class="attribute">proxy_redirect</span>     default;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">    <span class="attribute">proxy_max_temp_file_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>      <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>         <span class="number">90</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>         <span class="number">90</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span>          <span class="number">4k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span>              <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span>    <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3><span id="2-直接访问后端接口配置方法">2、直接访问后端接口，配置方法：</span></h3><ul><li>在web.xml中，增加跨域拦截器：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CORS跨域 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hoperun.core.filter.ResponseCorsFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/service/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/system/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>corsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>增加过滤器 ResponseCorsFilter ：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.hoperun.core.filter;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class ResponseCorsFilter implements Filter {</span><br><span class="line">   @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br><span class="line">      HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse alteredResponse = (HttpServletResponse) servletResponse;</span><br><span class="line">      </span><br><span class="line">      if (servletResponse instanceof HttpServletResponse) {</span><br><span class="line">            if (request.getMethod().equals("OPTION") || request.getMethod().equals("OPTIONS")) {</span><br><span class="line">                if (request.getServletPath().equals("/login")) {</span><br><span class="line">                    alteredResponse.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">                    addHeadersFor200Response(alteredResponse);</span><br><span class="line">                    return;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            addHeadersFor200Response(alteredResponse);</span><br><span class="line">        }</span><br><span class="line">      </span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void addHeadersFor200Response(HttpServletResponse response) {</span><br><span class="line">        response.addHeader("Access-Control-Allow-Origin", "*");</span><br><span class="line">        response.addHeader("Access-Control-Allow-Credentials", "true");</span><br><span class="line">        response.addHeader("Access-Control-Allow-Methods", "ACL, CANCELUPLOAD, CHECKIN, CHECKOUT, COPY, DELETE, GET, HEAD, LOCK, MKCALENDAR, MKCOL, MOVE, OPTIONS, POST, PROPFIND, PROPPATCH, PUT, REPORT, SEARCH, UNCHECKOUT, UNLOCK, UPDATE, VERSION-CONTROL");</span><br><span class="line">        response.addHeader("Access-Control-Allow-Headers", "useXDomain, withCredentials, Overwrite, Destination, Content-Type, Depth, User-Agent, Translate, Range, Content-Range, Timeout, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control, Location, Lock-Token, If");</span><br><span class="line">        response.addHeader("Access-Control-Expose-Headers", "DAV, content-length, Allow");</span><br><span class="line">        response.addHeader("Access-Control-Max-Age", "86400");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void destroy() {</span><br><span class="line">      // TODO Auto-generated method stub</span><br><span class="line">      </span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void init(FilterConfig arg0) throws ServletException {</span><br><span class="line">      // TODO Auto-generated method stub</span><br><span class="line">      </span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>请求返回时，response中增加：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></tbody></table></figure><p>​</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 跨域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC运行时序图</title>
      <link href="/2020/04/23/spring-mvc-yun-xing-shi-xu-tu/"/>
      <url>/2020/04/23/spring-mvc-yun-xing-shi-xu-tu/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring-mvc运行时序图">Spring MVC运行时序图</span></h1><p>Spring mvc运行，可以分为以下几个步骤：</p><ul><li>请求被映射到 HandlerMapping</li><li>HandlerMapping 通过 HandlerAdapter 动态处理参数，并返回 ModelAndView</li><li>ModelAndView 经过 ViewResolver 返回 View</li></ul><h3><span id="运行时序图">运行时序图</span></h3><p><img src="https://i.loli.net/2020/04/23/rgqt6XP2YBSduse.png" alt="Spring MVC运行时序图.png"></p><h2><span id="源码运行分析">源码运行分析</span></h2><h3><span id="初始化阶段">初始化阶段</span></h3><h4><span id="1-httpservletbeaninit">1、HttpServletBean.init()</span></h4><p> init() 是 Servlet 的初始化入口。主要完成读取配置文件，然后调用了一个自己定义模板方法 initServletBean ,通过子类来完成ServletBean  初始化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">90</span><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">//定位资源</span></span><br><span class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">//加载配置信息</span></span><br><span class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">         bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">         initBeanWrapper(bw);</span><br><span class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) {</span><br><span class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">   initServletBean();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4><span id="2-frameworkservletinitservletbean">2、FrameworkServlet.initServletBean()</span></h4><p>重写父类的initServletBean()方法，用来创建 WebApplicationContext  对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">//直接委派调用：initWebApplicationContext</span></span><br><span class="line">   <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">   initFrameworkServlet();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) {</span><br><span class="line">   <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) {</span><br><span class="line">   <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>initWebApplicationContext</li></ul><p>在 FrameworkServlet.initWebApplicationContext 方法中，完成了IOC容器（WebApplicationContext  ）的创建，但和MVC相关的，是 onRefresh 方法</p><h4><span id="3-dispatcherservletonrefresh">3、DispatcherServlet.onRefresh</span></h4><p>FrameworkServlet定义了一个空的模板方法onRefresh，让子类进行覆盖。而 DispatcherServlet 的 onRefresh 方法就是调用了 initStrategies ， 来初始化 MVC 九大组件：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化策略</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">   <span class="comment">//多文件上传的组件</span></span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   <span class="comment">//初始化本地语言环境</span></span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   <span class="comment">//初始化模板处理器</span></span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   <span class="comment">//handlerMapping</span></span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   <span class="comment">//初始化参数适配器</span></span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   <span class="comment">//初始化异常拦截器</span></span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   <span class="comment">//初始化视图预处理器</span></span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   <span class="comment">//初始化视图转换器</span></span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   <span class="comment">//初始化参数缓存器</span></span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="调用阶段">调用阶段</span></h2><h4><span id="1-dispatcherservletdoservice">1、DispatcherServlet.doService</span></h4><p>Servlet 调用方法的入口：doService </p><blockquote><p>公开DispatcherServlet的特定要求的属性和委托给doDispatch的实际调度</p></blockquote><ul><li><p>doDispatch 中央控制器,控制请求的转发</p><ol><li><p>检查是否是文件上传的请求</p></li><li><p>取得处理当前请求的controller，这里也称为hanlder，处理器,第一个步骤的意义就在这里体现了。这里并不是直接返回controller，而是返回的 HandlerExecutionChain 请求处理器链对象，该对象封装了handler和interceptors。</p><blockquote><p>interceptors ，就是 MVC 拦截器</p></blockquote></li><li><p>获取处理request的处理器适配器handler adapter</p></li><li><p>实际的处理器处理请求,返回结果视图对象</p></li></ol></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 中央控制器,控制请求的转发 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">   HttpServletRequest processedRequest = request;</span><br><span class="line">   HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">      Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 1.检查是否是文件上传的请求</span></span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">         <span class="comment">// 2.取得处理当前请求的controller,这里也称为hanlder,处理器,</span></span><br><span class="line">         <span class="comment">//      第一个步骤的意义就在这里体现了.这里并不是直接返回controller,</span></span><br><span class="line">         <span class="comment">//  而是返回的HandlerExecutionChain请求处理器链对象,</span></span><br><span class="line">         <span class="comment">//  该对象封装了handler和interceptors.</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="comment">// 如果handler为空,则返回404</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) {</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">         <span class="comment">//3. 获取处理request的处理器适配器handler adapter</span></span><br><span class="line">         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">         <span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">         <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) {</span><br><span class="line">            <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">               logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"> <span class="comment">//执行所有拦截器preHandle方法</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">         <span class="comment">// 4.实际的处理器处理请求,返回结果视图对象</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 结果视图对象的处理</span></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">         <span class="comment">//执行所有拦截器postHandle方法</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) {</span><br><span class="line">         <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">      }</span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) {</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">finally</span> {</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 请求成功响应之后的方法</span></span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) {</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>processDispatchResult</li></ul><p>处理分发结果。将 ModelAndView 或 Exception 统一解析为一个 ModelAndView ，然后调用 redener 完成渲染。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Exception exception)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">//将Exception 也处理为一个ModelAndView </span></span><br><span class="line">   <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) {</span><br><span class="line">         logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">         mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">         mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">         errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">   <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) {</span><br><span class="line">      <span class="comment">//调用渲染方法，渲染 ModelAndView</span></span><br><span class="line">      render(mv, request, response);</span><br><span class="line">      <span class="keyword">if</span> (errorView) {</span><br><span class="line">         WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">         logger.debug(<span class="string">"Null ModelAndView returned to DispatcherServlet with name '"</span> + getServletName() +</span><br><span class="line">               <span class="string">"': assuming HandlerAdapter completed request handling"</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {</span><br><span class="line">      <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) {</span><br><span class="line">      mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>render</p><p>渲染给定的ModelAndView：</p><ol><li>从 ModelAndView 取出 View</li><li>调用 View 的 render 方法，进行视图渲染</li></ol></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">   <span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">   Locale locale =</span><br><span class="line">         (<span class="keyword">this</span>.localeResolver != <span class="keyword">null</span> ? <span class="keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">   response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">   View view;</span><br><span class="line">   String viewName = mv.getViewName();</span><br><span class="line">   <span class="keyword">if</span> (viewName != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// We need to resolve the view name.</span></span><br><span class="line">      view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line">               <span class="string">"' in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">      <span class="comment">//1、从 ModelAndView 直接取出 View</span></span><br><span class="line">      view = mv.getView();</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">               <span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Delegate to the View object for rendering.</span></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">if</span> (mv.getStatus() != <span class="keyword">null</span>) {</span><br><span class="line">         response.setStatus(mv.getStatus().value());</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">//2、调用 View 的 render 方法，进行视图渲染</span></span><br><span class="line">      view.render(mv.getModelInternal(), request, response);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">         logger.debug(<span class="string">"Error rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> +</span><br><span class="line">               getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4><span id="2-abstractviewrender">2、AbstractView.render</span></h4><p> 这个方法里主要就是将一些 staticAttributes、requestContextAttribute 合并到 model中</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">      logger.trace(<span class="string">"Rendering view with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"' with model "</span> + model +</span><br><span class="line">         <span class="string">" and static attributes "</span> + <span class="keyword">this</span>.staticAttributes);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 合并属性到model</span></span><br><span class="line">   Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line">   prepareResponse(request, response);</span><br><span class="line">   <span class="comment">//最后将合并的model进行渲染输出</span></span><br><span class="line">   renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此至，MVC 调用完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring MVC运行时序图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式脑图</title>
      <link href="/2020/04/22/she-ji-mo-shi-nao-tu/"/>
      <url>/2020/04/22/she-ji-mo-shi-nao-tu/</url>
      
        <content type="html"><![CDATA[<h2><span id="设计模式脑图">设计模式脑图</span></h2><p>脑图中包含以下内容：</p><ul><li>七大设计原则</li><li>23种设计模式</li><li>设计模式分类</li><li>设计模式关联对比</li></ul><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;" width="100%" height="500" allowfullscreen="true" src="https://www.processon.com/view/link/5e9ff4067d9c0869da9c309e"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 脑图 </category>
          
          <category> 设计模式脑图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脑图 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring脑图</title>
      <link href="/2020/04/21/spring-nao-tu/"/>
      <url>/2020/04/21/spring-nao-tu/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-知识点脑图">Spring   知识点脑图</span></h2><blockquote><p>spring框架知识点，大概包含以下内容</p></blockquote><ul><li>IOC</li><li>DI</li><li>AOP</li><li>MVC</li></ul><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;" width="100%" height="500" allowfullscreen="true" src="https://www.processon.com/view/link/5e9ea8ad1e085346f711bcb6"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 脑图 </category>
          
          <category> Spring 脑图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 是如何解决循环依懒的？</title>
      <link href="/2020/04/20/spring-shi-ru-he-jie-jue-xun-huan-yi-lan-de/"/>
      <url>/2020/04/20/spring-shi-ru-he-jie-jue-xun-huan-yi-lan-de/</url>
      
        <content type="html"><![CDATA[<h2><span id="什么是循环依懒">什么是循环依懒？</span></h2><p>循环依懒，即依懒形成了一个循环，如：</p><ul><li>A依懒B，B依懒A</li><li>A依懒B，B依懒C，C依懒A</li></ul><h2><span id="spring-是如何解决的">Spring 是如何解决的</span></h2><p>spring 只能解决单例的，并且属性是非构造方法参数注入（set注入）的循环依懒。原理，就是运用缓存，如 getBean(“a”) 获取 A 的时候，先通过反射调用 A 的无参构造方法，创建 A 的 bean，并放入缓存容器。接着执行属性注入，发现 A 中有个 B 的引用属性，又会调用 getBean(“b”)获取 B 的bean，并放入缓存容器。接着执行属性注入，发现 B 中有个 A 的引用属性，又会调用 getBean(“a”)获取 A 的bean（此时形成循环）。这里有个很重要的点： getBean 的时候，都会先查询缓存容器，看是否已经创建过bean了，如果查询到了，就直接返回了。到这里，A 返回给了 B，B 又返回给 A，至此循环依懒完成了属性注入。</p><p><img src="https://i.loli.net/2020/04/20/KhApxaJrq95sXnO.png" alt="Spring 循环依懒运行时序图.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring 是如何解决循环依懒的？ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring加载AnnotationConfig到IOC容器方法调用时序</title>
      <link href="/2020/04/17/spring-jia-zai-annotation-dao-ioc-rong-qi/"/>
      <url>/2020/04/17/spring-jia-zai-annotation-dao-ioc-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring加载-annotationconfig-到ioc容器方法调用时序">Spring加载 AnnotationConfig 到IOC容器方法调用时序：</span></h1><p>Spring 4 之后是可以通过配置类来装载 bean 的，只要类上面加了 @Configuration ，即可以将这个类里面定义的bean 等来进行装载，如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Jzhao"</span>,<span class="number">28</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后简单地写个测试方法，通过 AnnotationConfigApplicationContext ，便可以将 MyConfig 中定义的 person 加载到 IOC 容器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Object bean = app.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        String [] beanNames = app.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(Arrays.toString(beanNames));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="annotationconfig-加载到-ioc-运行时序图">AnnotationConfig 加载到 IOC 运行时序图</span></h2><p><img src="https://i.loli.net/2020/04/17/BGKwdfRTcHPMA7y.png" alt="Spring 通过 Annotaton 配置 Class加载 IOC 时序图 _1_.png"></p><p>通过测试代码，我们大概能画出上面这个时序图。大概给它分成三个步骤：加载、注册、刷新。这里和 XML 加载有个很大不同的，就是XML，注册过程是放在刷新方法中的；而 Annotation 的方式，则是先注册 Bean 到 IOC，然后再刷新。</p><h3><span id="加载">加载</span></h3><p>通过 AnnotationConfigApplicationContext(Class… annotatedClasses) 这个构造函数，这个构造函数中只有三个方法，this()、this.register()、this.refresh()。加载，这里面我们主要看下this()</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 AnnotationConfigApplicationContext 构造方法，我们可以看出，AnnotationConfigApplicationContext 里面直接就放了一个 AnnotatedBeanDefinitionReader ，来用将 AnnotationConfig 解析成 BeanDefinition。</p><h3><span id="注册">注册</span></h3><p>this.register() 方法中就调用加载步骤创建的AnnotatedBeanDefinitionReader，来进行注册操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的</span></span><br><span class="line"><span class="comment">//refresh()方法刷新容器，触发容器对新注册的Bean的处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>{</span><br><span class="line">   Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  一步一步往下走，我们发现了doRegisterBean，这个真正干活的方法，该方法里面完成了BeanDefinition的创建，将前AnnotaionConfig中定义的属性设置到BeanDefinition，最后注册到IOC容器中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bean定义读取器向容器注册注解Bean定义类</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构</span></span><br><span class="line">   AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">   <span class="comment">//解析注解Bean定义的作用域，若@Scope("prototype")，则Bean为原型类型；</span></span><br><span class="line">   <span class="comment">//若@Scope("singleton")，则Bean为单态类型</span></span><br><span class="line">   ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">   <span class="comment">//为注解Bean定义设置作用域</span></span><br><span class="line">   abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">   <span class="comment">//为注解Bean定义生成Bean名称</span></span><br><span class="line">   String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理注解Bean定义中的通用注解</span></span><br><span class="line">   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">   <span class="comment">//如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。</span></span><br><span class="line">   <span class="comment">//主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解</span></span><br><span class="line">   <span class="comment">//Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称</span></span><br><span class="line">   <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {</span><br><span class="line">         <span class="comment">//如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选</span></span><br><span class="line">         <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) {</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置，</span></span><br><span class="line">         <span class="comment">//则该Bean为预实例化</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) {</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一</span></span><br><span class="line">         <span class="comment">//个autowiring自动依赖注入装配限定符，该Bean在进autowiring</span></span><br><span class="line">         <span class="comment">//自动依赖注入装配时，根据名称装配限定符指定的Bean</span></span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) {</span><br><span class="line">      customizer.customize(abd);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据</span></span><br><span class="line">   BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">   <span class="comment">//根据注解Bean定义类中配置的作用域，创建相应的代理对象</span></span><br><span class="line">   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">   <span class="comment">//向IOC容器注册注解Bean类定义对象</span></span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3><span id="刷新">刷新</span></h3><p>通过this.refresh()，调用了父类AnnotationConfigApplicationContext 的 refresh 方法。这里我们就会想到通过 XML 配置文件进行 Bean 装载的时候，也调的这个方法，而这个方法里面才完成了 Bean 的注册。可是通过 AnnotationConfig 的方式，我们上面已经完成过注册了。我们可能会担心这个 refresh 方法，不会再来一次注册吧。下面，我们先到那个关键的 obtainFreshBeanFactory 里来看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>refreshBeanFactory() 方法是委派给子类去实现的，这里我们发现，有两个子类：AbstractRefreshableApplicationContext、GenericApplicationContext 实现了这个方法：</p><p><img src="https://i.loli.net/2020/04/17/smD4HS8Cvb7QqtJ.jpg" alt="111.jpg"></p><p>AbstractRefreshableApplicationContext 我们知道，加载XML到IOC容器，就是用的它。而它的refreshBeanFactory 方法中，可以看出，一定会再创建一个IOC容器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">   <span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//创建IOC容器</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplavyName(), ex);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么剩下的，就是 GenericApplicationContext ，我们再回去看看 AnnotationConfigApplicationContext 正好也是继承了 GenericApplicationContext ：</p><p><img src="https://i.loli.net/2020/04/17/ebC3zcFd2mRDrjO.jpg" alt="222.jpg"></p><p>回到 GenericApplicationContext 的 refreshBeanFactory 方法，仅仅只是给IOC容器设置了一个序列ID：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws IllegalStateException {</span><br><span class="line">   if (!this.refreshed.compareAndSet(false, true)) {</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">            "GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once");</span><br><span class="line">   }</span><br><span class="line">   this.beanFactory.setSerializationId(getId());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，IOC容器刷新成功。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring加载AnnotationConfig到IOC容器方法调用时序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring加载XML配置到IOC容器方法调用时序</title>
      <link href="/2020/04/14/spring-jia-zai-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/"/>
      <url>/2020/04/14/spring-jia-zai-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-加载-xml-配置到ioc容器-方法调用时序">Spring 加载 XML 配置到IOC容器 方法调用时序：</span></h2><a id="more"></a><blockquote><p>HttpServletBean.init()</p><blockquote><p>FrameworkServlet.initServletBean() –&gt; initWebApplicationContext() –&gt; createWebApplicationContext() –&gt; configureAndRefreshWebApplicationContext()</p><blockquote><p>AbstractApplicationContext.refresh() –&gt; obtainFreshBeanFactory ()</p><blockquote><p>AbstractRefreshableApplicationContext.refreshBeanFactory()</p><blockquote><p>XmlWebApplicationContext.loadBeanDefinitions() –&gt; loadBeanDefinitions()</p><blockquote><p>XmlBeanDefinitionReader.loadBeanDefinitions() –&gt; doLoadBeanDefinitions() –&gt; registerBeanDefinitions()</p><blockquote><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions() –&gt; doRegisterBeanDefinitions() –&gt; parseBeanDefinitions() –&gt; parseDefaultElement()</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后的 parseDefaultElement 使用策略模式，解析具体的element。</p><h2><span id="ioc运行时序图">IOC运行时序图</span></h2><p><img src="https://i.loli.net/2020/04/16/wZSCUMEqoas8Kz7.png" alt="Spring 5 IOC运行时序图.png"></p><p> spring 的IOC初始化过程，还是比较复杂的。里面比较重点的是IOC容器（BeanFactory）对象的在初始化过程中的传递：</p><ul><li>首先会在 AbstractRefreshableApplicationContext .refreshBeanFactory() 方法中调用createBeanFactory（）完成 IOC容器创建，并通 <code>this.beanFactory = beanFactory;</code>完成将IOC设置到ApplicattionContext 上下文中。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"><span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//创建IOC容器</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接着通过 loadBeanDefinitions 方法，将 beanFactory 传递到 AbstractXmlApplicationContext 中，AbstractXmlApplicationContext 反手就创建了 XmlBeanDefinitionReader 对象，并将 beanFactory 给了它：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br></pre></td></tr></tbody></table></figure><ul><li>继续往下，XmlBeanDefinitionReader 按管了配置文件解析，但它并不是真正干活的对象，而是通过自身属性 documentReaderClass 指定的 Class：DefaultBeanDefinitionDocumentReader ,来创建了一个真正解析XML文件的委派对象：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建BeanDefinitionDocumentReader对象，解析Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> BeanDefinitionDocumentReader<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">BeanUtils</span>.<span class="title">instantiateClass</span>(<span class="title">this</span>.<span class="title">documentReaderClass</span>))</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建后 BeanDefinitionDocumentReader 对象后，XmlBeanDefinitionReader  又将自身注册成 BeanDefinitionDocumentReader 的 readerContext  属性中：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this 参数将 XmlBeanDefinitionReader 传给了 XmlReaderContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">         <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>{</span><br><span class="line">   <span class="comment">//获得XML描述符</span></span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   <span class="comment">//获得Document的根元素</span></span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后通 getReaderContext().getRegistry() 获取到 BeanFactory ,将 bdHolder 中包装 BeanDefinition 注册到BeanFactory 的 IOC 容器Map中：beanDefinitionMap</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向IOC容器注册BeanDefinition（这里的 registry 即是刚开始解析时创建的IOC容器DefaultListableBeanFactory ）</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring加载XML配置到IOC容器方法调用时序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5注解编程基础组件介绍</title>
      <link href="/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/"/>
      <url>/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-配置组件">1、配置组件</span></h2><a id="more"></a><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>把一个类作为一个 IoC 容器，它的某个方法头上如果注册了 @Bean,就会作为这个 Spring 容器中的 Bean。</td></tr><tr><td>@ComponentScan</td><td>在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下的所有的配置类，相当于之前的&lt;context:component-scan&gt;</td></tr><tr><td>@Scope</td><td>用于指定scope作用域的（用在类上）</td></tr><tr><td>@Lazy</td><td>表示延时初始化</td></tr><tr><td>@Conditional</td><td>Spring4开始提供，它的作用是按照一定的条件进行判断，满足条件给容器注册Bean</td></tr><tr><td>@Import</td><td>导入外部资源</td></tr><tr><td>生命周期控制</td><td>@PostConstruct用于指定初始化方法（用在方法上）<br>@PreDestory用于指定销毁方法（用在方法上）<br>@DependsOn:定义Bean初始化及销毁时的顺序</td></tr></tbody></table><h2><span id="赋值自动装配组件">赋值（自动装配）组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</td></tr><tr><td>@Service</td><td>用于标注业务层组件</td></tr><tr><td>@Controller</td><td>用于标注控制层组件</td></tr><tr><td>@Repository</td><td>用于标注数据访问组件，即DAO组件。</td></tr><tr><td>@Value</td><td>普通数据类型赋值</td></tr><tr><td>@Autowired</td><td>默认按类型装配，如果我们想按名称装配，可以结合@Qualifier注解一起使用</td></tr><tr><td>@PropertySource</td><td>读取配置文件赋值</td></tr><tr><td>@Qualifier</td><td>如存在多个实例配合使用</td></tr><tr><td>@Primary</td><td>自动装配时当出现了多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</td></tr><tr><td>@Resource</td><td>默认按名称装配，当找不到与名称匹配的bean才会按类型装配</td></tr></tbody></table><h2><span id="织入组件">织入组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>ApplicationContextAware</td><td>可以通过这个上下文环境对象得到Spring容器中的Bean</td></tr><tr><td>BeanDefinitionRegistryPostProcessor</td><td>BeanDefinitionRegistryPostProcessor实现了BeanFactoryPostProcessor接口，是Spring框架的BeanDefinitionRegistry的后外理器，用来注册额外的BeanDefinition</td></tr></tbody></table><h2><span id="切面组件">切面组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@EnableTransactionManagement</td><td>添加对事务管理的支持</td></tr><tr><td>@Ttranscational</td><td>配置声明式事务信息</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring5注解编程基础组件介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码学习</title>
      <link href="/2020/04/08/spring-yuan-ma-xue-xi/"/>
      <url>/2020/04/08/spring-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-spring源码学习">咕泡学院-Spring源码学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91Spring%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E4%B8%8ESpring%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.pdf" target="_blank" rel="noopener">Spring前世今生与Spring编程思想</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A8300%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E5%88%9D%E4%BD%93%E9%AA%8CSpring+V1.0%E7%89%88%E6%9C%AC.pdf" target="_blank" rel="noopener">用300行代码手写初体验Spring+V1.0版本</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A830%E4%B8%AA%E7%B1%BB%E6%89%8B%E5%86%99Spring+V2.0%E7%89%88%E6%9C%AC%E4%B9%8B%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1IOC%E4%B8%8EDI.pdf" target="_blank" rel="noopener">用30个类手写Spring+V2.0版本之顶层设计IOC与DI</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> Spring源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM升华篇</title>
      <link href="/2020/04/07/jvm-sheng-hua-pian/"/>
      <url>/2020/04/07/jvm-sheng-hua-pian/</url>
      
        <content type="html"><![CDATA[<h1><span id="garbage-collect垃圾回收">Garbage Collect(垃圾回收)</span></h1><a id="more"></a><h2><span id="何为垃圾">何为垃圾：</span></h2><h3><span id="如何确定一个对象是垃圾">如何确定一个对象是垃圾？</span></h3><ol><li><p>引用计数法：</p><p>对于对象而言，如果程序中没有任何对象引用它，它就是垃圾。</p><p>弊端：会存在循环引用，A引用B，B又引用A。而如果此时，A,B都没有被其他对象引用，A,B也是垃圾，但如果用引用计数法，则无法判断它们是垃圾。</p></li><li><p>可达性分析：</p><p>通过GC Root对象，开始向下寻找，看某个对象是否可达  。这里的GC Root (上帝视角），个人理解就是引用的根节点对象，就像一个菜单树一样，通过根节点，就可以向下找到所有的子节点。</p><blockquote><p>什么样的对象可以是GC Root？</p><ul><li>虚拟机栈中的本地变量表</li><li>static成员</li><li>常量引用</li><li>本地方法栈中的变量</li><li>类加载器</li><li>Thread 等</li></ul></blockquote></li></ol><h2><span id="垃圾回收算法">垃圾回收算法：</span></h2><h3><span id="标记-清除mark-sweep">标记-清除（Mark-Sweep）</span></h3><ul><li><p>标记</p><p>找出内存中需要回收的对象，并把它们标记出来</p><blockquote><p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p></li></ul><ul><li><p>清除</p><p>清除掉被标记需要回收的对象，释放出对应的内存空间</p><p><img src="https://i.loli.net/2020/04/08/dIe72hczMiu4r8o.jpg" alt="QQ截图20200408093244.jpg"></p><p>缺点</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span><br><span class="line">1.标记和清除两个过程都比较耗时，效率不高</span><br><span class="line">2.会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span><br></pre></td></tr></tbody></table></figure></li></ul><h3><span id="复制copying">复制（Copying）</span></h3><p>将内存划分成两块相等的区域，每次只使用其中一块，如下图所示：</p><p><img src="https://i.loli.net/2020/04/08/Qsa1dX378V6C2H9.jpg" alt="QQ截图20200408093314.jpg"></p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次性清除掉。</p><p><img src="https://i.loli.net/2020/04/08/HZnAu4pEP6VUSXc.jpg" alt="QQ截图20200408093333.jpg"></p><p>缺点：空间利用率降低。</p><h3><span id="标记-整理mark-compact">标记-整理（Mark-Compact）</span></h3><p>标记过程仍然与“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p><p>让所有存活的对象都向一端移动，清理掉边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/JKIWv6TCErfPaSj.jpg" alt="QQ截图20200408093407.jpg"></p><h2><span id="分代收集算法">分代收集算法</span></h2><blockquote><p>既然上面介绍了3种垃圾收集算法，那么在堆内存中到底用哪一个呢？</p></blockquote><p>Young区：复制算法（对象在被分配之后，可能生命周期比较短，Young区复制效率比较高）</p><p>Old区：标记-清除、标记-整理（Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理）</p><h2><span id="垃圾收集器">垃圾收集器</span></h2><blockquote><p>如果说收集器算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，说白了就是落地。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/hlEaNArspbQiPUM.jpg" alt="QQ截图20200408093426.jpg"></p><h3><span id="serial收集器">Serial收集器</span></h3><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。</p><p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：简单高效，拥有很高的单线程收集效率</span><br><span class="line">缺点：收集过程需要暂停所有线程</span><br><span class="line">算法：复制算法</span><br><span class="line">适用范围：新生代</span><br><span class="line">应用：Client模式下的默认新生代收集器</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/f4d6lO7IGPnowYU.jpg" alt="QQ截图20200408093449.jpg"></p><h3><span id="parnew收集器">ParNew收集器</span></h3><p>可以把这个收集器理解为Serial收集器的多线程版本。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：在多CPU时，比Serial效率高。</span><br><span class="line">缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。</span><br><span class="line">算法：复制算法</span><br><span class="line">适用范围：新生代</span><br><span class="line">应用：运行在Server模式下的虚拟机中首选的新生代收集器</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/bExoILRW47shVpH.jpg" alt="QQ截图20200408093515.jpg"></p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是ParallelScavenge更关注<strong><em>系统的吞吐量</em></strong>。</p><blockquote><p>吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）</p><p>比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=（100-1）/100=99%</p><p>若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--XX:MAXGCPuauseMillis控制最大的垃圾收集停顿时间。</span><br><span class="line">--XX:GCTimeRatio直接设置吞吐量的大小。</span><br></pre></td></tr></tbody></table></figure><h3><span id="serial-old收集器">Serial Old收集器</span></h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“标记-整理法”，运行过程和Serial收集器一样。</p><p><img src="https://i.loli.net/2020/04/08/8435ulwcrxMIePT.jpg" alt="QQ截图20200408093528.jpg"></p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”进行垃圾回收。</p><p><strong><em>吞吐量优先</em></strong></p><h3><span id="cms收集器">CMS收集器</span></h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong><em>最短回收停顿时间</em></strong>为目标的收集器。</p><p>采用的是“标记-清除算法”，整个过程分为4步</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.初始标记 CMS initial mark 标记GC Roots能关联到的对象 Stop The World--&gt;速度很快</span><br><span class="line">2.并发标记 CMS concurrent mark 进行GC Roots Tracking</span><br><span class="line">3.重新标记 CMS remark 修改并发标记因用户程序变动的内容Stop The World</span><br><span class="line">4.并发清除 CMS concurrent sweep</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：并发收集、低停顿</span><br><span class="line">缺点：产生大量空间碎片、并发阶段会降低吞吐量</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/rOmbwLZuMiv63jH.jpg" alt="QQ截图20200408093541.jpg"></p><h3><span id="g1收集器">G1收集器</span></h3><p>G1特点</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并行与并发</span><br><span class="line">分代收集（仍然保留了分代的概念）</span><br><span class="line">空间整合（整体上属于“标记-整理”算法，不会导致这僮碎片）</span><br><span class="line">可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p></blockquote><p>工作过程可以分为如下几步</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程</span><br><span class="line">并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行</span><br><span class="line">最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程</span><br><span class="line">筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制度回收计划</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/4djyBHMPKu8a1f3.jpg" alt="QQ截图20200408093556.jpg"></p><h3><span id="垃圾收集器分类">垃圾收集器分类</span></h3><ul><li>串行收集器–&gt;Serial和Serial Old</li></ul><p>只能有一个垃圾回收线程执行，用户线程暂停。<strong><em>适用于内存比较小的嵌入式设备</em></strong>。</p><ul><li>并行收集器【吞吐量优先】–&gt;Parallel Scavenge、Parallel Old</li></ul><p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<strong><em>适用于科学计算、后台处理等交互场景</em></strong>。</p><ul><li>并发收集器【停顿时间优先】–&gt;CMS、G1</li></ul><p>用户线程和垃圾收集线程同时执行（但并不一 定是并行的，可能是交替执行的），垃圾收集线程在执行的时候不会停顿用户线程的运行。<strong><em>适用于相对时间有要求的场景，比如web</em></strong>。</p><h3><span id="理解吞吐量和停顿时间">理解吞吐量和停顿时间</span></h3><ul><li>停顿时间–&gt;垃圾收集器进行垃圾回收终端应用执行响应的时间</li><li>吞吐量–&gt;运行用户代码时间/ (运行用户代码时间+垃圾收集时间)</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；</span><br><span class="line">高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</span><br></pre></td></tr></tbody></table></figure><p><strong><em>小结</em></strong>：这两个指标也是评价垃圾回收器好坏的标准，其实调优也就是在观察这两个变量。</p><h3><span id="如何选择合适的垃圾收集器">如何选择合适的垃圾收集器</span></h3><p>官网：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></p><ul><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M,使用串行收集器</li><li>如是是单核，并且没有停顿时间要求，使用串行或JVM自己选</li><li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ul><h3><span id="再次理解g1">再次理解G1</span></h3><blockquote><p> JDK 7开始使用，JDK 8非常成熟，JDK 9 默认的增垃圾收集器，适用于新老生代。</p></blockquote><p>判断是否需要使用G1收集器？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.50%以上的堆被存活对象占用</span><br><span class="line">2.对象分配和晋升的速度变化非常大</span><br><span class="line">3.垃圾回收时间比较长</span><br></pre></td></tr></tbody></table></figure><h3><span id="如何开启需要的垃圾收集器">如何开启需要的垃圾收集器</span></h3><ol><li><p>串行</p><p>–XX:+UserSerialGC</p><p>–XX:+UserSerialoldGC</p></li><li><p>并行（吞吐量优先）</p><p>–XX:+UseParallelGC</p><p>–XX:+UseParalleloldGC</p></li><li><p>并发（响应时间优先）</p><p>–XX:+UseConcMarkSweepGC</p><p>–XX:+UseG1GC</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM升华篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Garbage Collect(垃圾回收) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习</title>
      <link href="/2020/04/07/she-ji-mo-shi-xue-xi/"/>
      <url>/2020/04/07/she-ji-mo-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-设计模式学习">咕泡学院-设计模式学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88%E5%8F%8A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">设计模式总览及工厂模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">单例模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">原型模式与建造者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/04_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">深度分析代理模式</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/05_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">门面模式与装饰器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/06_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">享元模式与组合模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/07_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">适配器模式与桥接模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/08_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">委派模式与模板方法模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/09_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">策略模式与责任链模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/10_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">迭代器模式与命令模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/11_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">状态模式与备忘录模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/12_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">中介者模式与解释器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/13_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">观察者模式与访问者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/14_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94.pdf" target="_blank" rel="noopener">各设计模式总结与对比</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> 设计模式学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
