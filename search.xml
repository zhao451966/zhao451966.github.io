<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring加载XML配置到IOC容器方法调用时序</title>
      <link href="/2020/04/14/spring-jia-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/"/>
      <url>/2020/04/14/spring-jia-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-加载-xml-配置到ioc容器-方法调用时序">Spring 加载 XML 配置到IOC容器 方法调用时序：</span></h2><a id="more"></a><blockquote><p>HttpServletBean.init()</p><blockquote><p>FrameworkServlet.initServletBean() –&gt; initWebApplicationContext() –&gt; createWebApplicationContext() –&gt; configureAndRefreshWebApplicationContext()</p><blockquote><p>AbstractApplicationContext.refresh() –&gt; obtainFreshBeanFactory ()</p><blockquote><p>AbstractRefreshableApplicationContext.refreshBeanFactory()</p><blockquote><p>XmlWebApplicationContext.loadBeanDefinitions() –&gt; loadBeanDefinitions()</p><blockquote><p>XmlBeanDefinitionReader.loadBeanDefinitions() –&gt; doLoadBeanDefinitions() –&gt; registerBeanDefinitions()</p><blockquote><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions() –&gt; doRegisterBeanDefinitions() –&gt; parseBeanDefinitions() –&gt; parseDefaultElement()</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre><code class="java">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {        importBeanDefinitionResource(ele);    }    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {        processAliasRegistration(ele);    }    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {        processBeanDefinition(ele, delegate);    }    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {        // recurse        doRegisterBeanDefinitions(ele);    }}</code></pre><p>最后的 parseDefaultElement 使用策略模式，解析具体的element。</p><h2><span id="ioc运行时序图">IOC运行时序图</span></h2><p><img src="https://i.loli.net/2020/04/16/wZSCUMEqoas8Kz7.png" alt="Spring 5 IOC运行时序图.png"></p><p> spring 的IOC初始化过程，还是比较复杂的。里面比较重点的是IOC容器（BeanFactory）对象的在初始化过程中的传递：</p><ul><li>首先会在 AbstractRefreshableApplicationContext .refreshBeanFactory() 方法中调用createBeanFactory（）完成 IOC容器创建，并通 <code>this.beanFactory = beanFactory;</code>完成将IOC设置到ApplicattionContext 上下文中。</li></ul><pre><code class="java">    @Override    protected final void refreshBeanFactory() throws BeansException {        //如果已经有容器，销毁容器中的bean，关闭容器        if (hasBeanFactory()) {            destroyBeans();            closeBeanFactory();        }        try {            //创建IOC容器            DefaultListableBeanFactory beanFactory = createBeanFactory();            beanFactory.setSerializationId(getId());            //对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等            customizeBeanFactory(beanFactory);            //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器            loadBeanDefinitions(beanFactory);            synchronized (this.beanFactoryMonitor) {                this.beanFactory = beanFactory;            }        }        catch (IOException ex) {            throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);        }    }</code></pre><ul><li>接着通过 loadBeanDefinitions 方法，将 beanFactory 传递到 AbstractXmlApplicationContext 中，AbstractXmlApplicationContext 反手就创建了 XmlBeanDefinitionReader 对象，并将 beanFactory 给了它：</li></ul><pre><code class="java">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</code></pre><ul><li>继续往下，XmlBeanDefinitionReader 按管了配置文件解析，但它并不是真正干活的对象，而是通过自身属性 documentReaderClass 指定的 Class：DefaultBeanDefinitionDocumentReader ,来创建了一个真正解析XML文件的委派对象：</li></ul><pre><code class="java">//创建BeanDefinitionDocumentReader对象，解析Document对象protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {   return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));}</code></pre><ul><li>创建后 BeanDefinitionDocumentReader 对象后，XmlBeanDefinitionReader  又将自身注册成 BeanDefinitionDocumentReader 的 readerContext  属性中：</li></ul><pre><code class="java">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</code></pre><pre><code class="java">//this 参数将 XmlBeanDefinitionReader 传给了 XmlReaderContextpublic XmlReaderContext createReaderContext(Resource resource) {   return new XmlReaderContext(resource, this.problemReporter, this.eventListener,         this.sourceExtractor, this, getNamespaceHandlerResolver());}</code></pre><pre><code class="java">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {   //获得XML描述符   this.readerContext = readerContext;   logger.debug("Loading bean definitions");   //获得Document的根元素   Element root = doc.getDocumentElement();   doRegisterBeanDefinitions(root);}</code></pre><ul><li>最后通 getReaderContext().getRegistry() 获取到 BeanFactory ,将 bdHolder 中包装 BeanDefinition 注册到BeanFactory 的 IOC 容器Map中：beanDefinitionMap</li></ul><pre><code class="java">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</code></pre><pre><code class="java">//向IOC容器注册BeanDefinition（这里的 registry 即是刚开始解析时创建的IOC容器DefaultListableBeanFactory ）registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring加载XML配置到IOC容器方法调用时序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5注解编程基础组件介绍</title>
      <link href="/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/"/>
      <url>/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-配置组件">1、配置组件</span></h2><a id="more"></a><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>把一个类作为一个 IoC 容器，它的某个方法头上如果注册了 @Bean,就会作为这个 Spring 容器中的 Bean。</td></tr><tr><td>@ComponentScan</td><td>在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下的所有的配置类，相当于之前的&lt;context:component-scan&gt;</td></tr><tr><td>@Scope</td><td>用于指定scope作用域的（用在类上）</td></tr><tr><td>@Lazy</td><td>表示延时初始化</td></tr><tr><td>@Conditional</td><td>Spring4开始提供，它的作用是按照一定的条件进行判断，满足条件给容器注册Bean</td></tr><tr><td>@Import</td><td>导入外部资源</td></tr><tr><td>生命周期控制</td><td>@PostConstruct用于指定初始化方法（用在方法上）<br>@PreDestory用于指定销毁方法（用在方法上）<br>@DependsOn:定义Bean初始化及销毁时的顺序</td></tr></tbody></table><h2><span id="赋值自动装配组件">赋值（自动装配）组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</td></tr><tr><td>@Service</td><td>用于标注业务层组件</td></tr><tr><td>@Controller</td><td>用于标注控制层组件</td></tr><tr><td>@Repository</td><td>用于标注数据访问组件，即DAO组件。</td></tr><tr><td>@Value</td><td>普通数据类型赋值</td></tr><tr><td>@Autowired</td><td>默认按类型装配，如果我们想按名称装配，可以结合@Qualifier注解一起使用</td></tr><tr><td>@PropertySource</td><td>读取配置文件赋值</td></tr><tr><td>@Qualifier</td><td>如存在多个实例配合使用</td></tr><tr><td>@Primary</td><td>自动装配时当出现了多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</td></tr><tr><td>@Resource</td><td>默认按名称装配，当找不到与名称匹配的bean才会按类型装配</td></tr></tbody></table><h2><span id="织入组件">织入组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>ApplicationContextAware</td><td>可以通过这个上下文环境对象得到Spring容器中的Bean</td></tr><tr><td>BeanDefinitionRegistryPostProcessor</td><td>BeanDefinitionRegistryPostProcessor实现了BeanFactoryPostProcessor接口，是Spring框架的BeanDefinitionRegistry的后外理器，用来注册额外的BeanDefinition</td></tr></tbody></table><h2><span id="切面组件">切面组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@EnableTransactionManagement</td><td>添加对事务管理的支持</td></tr><tr><td>@Ttranscational</td><td>配置声明式事务信息</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring5注解编程基础组件介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码学习</title>
      <link href="/2020/04/08/spring-yuan-ma-xue-xi/"/>
      <url>/2020/04/08/spring-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-spring源码学习">咕泡学院-Spring源码学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91Spring%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E4%B8%8ESpring%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.pdf" target="_blank" rel="noopener">Spring前世今生与Spring编程思想</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A8300%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E5%88%9D%E4%BD%93%E9%AA%8CSpring+V1.0%E7%89%88%E6%9C%AC.pdf" target="_blank" rel="noopener">用300行代码手写初体验Spring+V1.0版本</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A830%E4%B8%AA%E7%B1%BB%E6%89%8B%E5%86%99Spring+V2.0%E7%89%88%E6%9C%AC%E4%B9%8B%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1IOC%E4%B8%8EDI.pdf" target="_blank" rel="noopener">用30个类手写Spring+V2.0版本之顶层设计IOC与DI</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> Spring源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习</title>
      <link href="/2020/04/07/she-ji-mo-shi-xue-xi/"/>
      <url>/2020/04/07/she-ji-mo-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-设计模式学习">咕泡学院-设计模式学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88%E5%8F%8A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">设计模式总览及工厂模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">单例模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">原型模式与建造者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/04_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">深度分析代理模式</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/05_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">门面模式与装饰器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/06_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">享元模式与组合模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/07_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">适配器模式与桥接模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/08_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">委派模式与模板方法模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/09_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">策略模式与责任链模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/10_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">迭代器模式与命令模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/11_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">状态模式与备忘录模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/12_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">中介者模式与解释器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/13_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">观察者模式与访问者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/14_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94.pdf" target="_blank" rel="noopener">各设计模式总结与对比</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> 设计模式学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM升华篇</title>
      <link href="/2020/04/07/jvm-sheng-hua-pian/"/>
      <url>/2020/04/07/jvm-sheng-hua-pian/</url>
      
        <content type="html"><![CDATA[<h1><span id="garbage-collect垃圾回收">Garbage Collect(垃圾回收)</span></h1><a id="more"></a><h2><span id="何为垃圾">何为垃圾：</span></h2><h3><span id="如何确定一个对象是垃圾">如何确定一个对象是垃圾？</span></h3><ol><li><p>引用计数法：</p><p>对于对象而言，如果程序中没有任何对象引用它，它就是垃圾。</p><p>弊端：会存在循环引用，A引用B，B又引用A。而如果此时，A,B都没有被其他对象引用，A,B也是垃圾，但如果用引用计数法，则无法判断它们是垃圾。</p></li><li><p>可达性分析：</p><p>通过GC Root对象，开始向下寻找，看某个对象是否可达  。这里的GC Root (上帝视角），个人理解就是引用的根节点对象，就像一个菜单树一样，通过根节点，就可以向下找到所有的子节点。</p><blockquote><p>什么样的对象可以是GC Root？</p><ul><li>虚拟机栈中的本地变量表</li><li>static成员</li><li>常量引用</li><li>本地方法栈中的变量</li><li>类加载器</li><li>Thread 等</li></ul></blockquote></li></ol><h2><span id="垃圾回收算法">垃圾回收算法：</span></h2><h3><span id="标记-清除mark-sweep">标记-清除（Mark-Sweep）</span></h3><ul><li><p>标记</p><p>找出内存中需要回收的对象，并把它们标记出来</p><blockquote><p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p></li></ul><ul><li><p>清除</p><p>清除掉被标记需要回收的对象，释放出对应的内存空间</p><p><img src="https://i.loli.net/2020/04/08/dIe72hczMiu4r8o.jpg" alt="QQ截图20200408093244.jpg"></p><p>缺点</p><pre><code>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。1.标记和清除两个过程都比较耗时，效率不高2.会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</code></pre></li></ul><h3><span id="复制copying">复制（Copying）</span></h3><p>将内存划分成两块相等的区域，每次只使用其中一块，如下图所示：</p><p><img src="https://i.loli.net/2020/04/08/Qsa1dX378V6C2H9.jpg" alt="QQ截图20200408093314.jpg"></p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次性清除掉。</p><p><img src="https://i.loli.net/2020/04/08/HZnAu4pEP6VUSXc.jpg" alt="QQ截图20200408093333.jpg"></p><p>缺点：空间利用率降低。</p><h3><span id="标记-整理mark-compact">标记-整理（Mark-Compact）</span></h3><p>标记过程仍然与“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p><p>让所有存活的对象都向一端移动，清理掉边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/JKIWv6TCErfPaSj.jpg" alt="QQ截图20200408093407.jpg"></p><h2><span id="分代收集算法">分代收集算法</span></h2><blockquote><p>既然上面介绍了3种垃圾收集算法，那么在堆内存中到底用哪一个呢？</p></blockquote><p>Young区：复制算法（对象在被分配之后，可能生命周期比较短，Young区复制效率比较高）</p><p>Old区：标记-清除、标记-整理（Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理）</p><h2><span id="垃圾收集器">垃圾收集器</span></h2><blockquote><p>如果说收集器算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，说白了就是落地。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/hlEaNArspbQiPUM.jpg" alt="QQ截图20200408093426.jpg"></p><h3><span id="serial收集器">Serial收集器</span></h3><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。</p><p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。</p><pre><code>优点：简单高效，拥有很高的单线程收集效率缺点：收集过程需要暂停所有线程算法：复制算法适用范围：新生代应用：Client模式下的默认新生代收集器</code></pre><p><img src="https://i.loli.net/2020/04/08/f4d6lO7IGPnowYU.jpg" alt="QQ截图20200408093449.jpg"></p><h3><span id="parnew收集器">ParNew收集器</span></h3><p>可以把这个收集器理解为Serial收集器的多线程版本。</p><pre><code>优点：在多CPU时，比Serial效率高。缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。算法：复制算法适用范围：新生代应用：运行在Server模式下的虚拟机中首选的新生代收集器</code></pre><p><img src="https://i.loli.net/2020/04/08/bExoILRW47shVpH.jpg" alt="QQ截图20200408093515.jpg"></p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是ParallelScavenge更关注<strong><em>系统的吞吐量</em></strong>。</p><blockquote><p>吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）</p><p>比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=（100-1）/100=99%</p><p>若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p></blockquote><pre><code>--XX:MAXGCPuauseMillis控制最大的垃圾收集停顿时间。--XX:GCTimeRatio直接设置吞吐量的大小。</code></pre><h3><span id="serial-old收集器">Serial Old收集器</span></h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“标记-整理法”，运行过程和Serial收集器一样。</p><p><img src="https://i.loli.net/2020/04/08/8435ulwcrxMIePT.jpg" alt="QQ截图20200408093528.jpg"></p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”进行垃圾回收。</p><p><strong><em>吞吐量优先</em></strong></p><h3><span id="cms收集器">CMS收集器</span></h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong><em>最短回收停顿时间</em></strong>为目标的收集器。</p><p>采用的是“标记-清除算法”，整个过程分为4步</p><pre><code>1.初始标记 CMS initial mark 标记GC Roots能关联到的对象 Stop The World--&gt;速度很快2.并发标记 CMS concurrent mark     进行GC Roots Tracking3.重新标记 CMS remark     修改并发标记因用户程序变动的内容    Stop The World4.并发清除 CMS concurrent sweep</code></pre><blockquote><p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p></blockquote><pre><code>优点：并发收集、低停顿缺点：产生大量空间碎片、并发阶段会降低吞吐量</code></pre><p><img src="https://i.loli.net/2020/04/08/rOmbwLZuMiv63jH.jpg" alt="QQ截图20200408093541.jpg"></p><h3><span id="g1收集器">G1收集器</span></h3><p>G1特点</p><pre><code>并行与并发分代收集（仍然保留了分代的概念）空间整合（整体上属于“标记-整理”算法，不会导致这僮碎片）可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</code></pre><blockquote><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p></blockquote><p>工作过程可以分为如下几步</p><pre><code>初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制度回收计划</code></pre><p><img src="https://i.loli.net/2020/04/08/4djyBHMPKu8a1f3.jpg" alt="QQ截图20200408093556.jpg"></p><h3><span id="垃圾收集器分类">垃圾收集器分类</span></h3><ul><li>串行收集器–&gt;Serial和Serial Old</li></ul><p>只能有一个垃圾回收线程执行，用户线程暂停。<strong><em>适用于内存比较小的嵌入式设备</em></strong>。</p><ul><li>并行收集器【吞吐量优先】–&gt;Parallel Scavenge、Parallel Old</li></ul><p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<strong><em>适用于科学计算、后台处理等交互场景</em></strong>。</p><ul><li>并发收集器【停顿时间优先】–&gt;CMS、G1</li></ul><p>用户线程和垃圾收集线程同时执行（但并不一 定是并行的，可能是交替执行的），垃圾收集线程在执行的时候不会停顿用户线程的运行。<strong><em>适用于相对时间有要求的场景，比如web</em></strong>。</p><h3><span id="理解吞吐量和停顿时间">理解吞吐量和停顿时间</span></h3><ul><li>停顿时间–&gt;垃圾收集器进行垃圾回收终端应用执行响应的时间</li><li>吞吐量–&gt;运行用户代码时间/ (运行用户代码时间+垃圾收集时间)</li></ul><pre><code>停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</code></pre><p><strong><em>小结</em></strong>：这两个指标也是评价垃圾回收器好坏的标准，其实调优也就是在观察这两个变量。</p><h3><span id="如何选择合适的垃圾收集器">如何选择合适的垃圾收集器</span></h3><p>官网：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></p><ul><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M,使用串行收集器</li><li>如是是单核，并且没有停顿时间要求，使用串行或JVM自己选</li><li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ul><h3><span id="再次理解g1">再次理解G1</span></h3><blockquote><p> JDK 7开始使用，JDK 8非常成熟，JDK 9 默认的增垃圾收集器，适用于新老生代。</p></blockquote><p>判断是否需要使用G1收集器？</p><pre><code>1.50%以上的堆被存活对象占用2.对象分配和晋升的速度变化非常大3.垃圾回收时间比较长</code></pre><h3><span id="如何开启需要的垃圾收集器">如何开启需要的垃圾收集器</span></h3><ol><li><p>串行</p><p>–XX:+UserSerialGC</p><p>–XX:+UserSerialoldGC</p></li><li><p>并行（吞吐量优先）</p><p>–XX:+UseParallelGC</p><p>–XX:+UseParalleloldGC</p></li><li><p>并发（响应时间优先）</p><p>–XX:+UseConcMarkSweepGC</p><p>–XX:+UseG1GC</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM升华篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Garbage Collect(垃圾回收) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
