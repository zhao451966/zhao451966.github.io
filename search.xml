<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式脑图</title>
      <link href="/2020/04/22/she-ji-mo-shi-nao-tu/"/>
      <url>/2020/04/22/she-ji-mo-shi-nao-tu/</url>
      
        <content type="html"><![CDATA[<h2><span id="设计模式脑图">设计模式脑图</span></h2><p>脑图中包含以下内容：</p><ul><li>七大设计原则</li><li>23种设计模式</li><li>设计模式分类</li><li>设计模式关联对比</li></ul><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;" width="100%" height="500" allowfullscreen="true" src="https://www.processon.com/view/link/5e9ff4067d9c0869da9c309e"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 脑图 </category>
          
          <category> 设计模式脑图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring脑图</title>
      <link href="/2020/04/21/spring-nao-tu/"/>
      <url>/2020/04/21/spring-nao-tu/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-知识点脑图">Spring   知识点脑图</span></h2><blockquote><p>spring框架知识点，大概包含以下内容</p></blockquote><ul><li>IOC</li><li>DI</li><li>AOP</li><li>MVC</li></ul><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;" width="100%" height="500" allowfullscreen="true" src="https://www.processon.com/view/link/5e9ea8ad1e085346f711bcb6"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 脑图 </category>
          
          <category> Spring 脑图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 是如何解决循环依懒的？</title>
      <link href="/2020/04/20/spring-shi-ru-he-jie-jue-xun-huan-yi-lan-de/"/>
      <url>/2020/04/20/spring-shi-ru-he-jie-jue-xun-huan-yi-lan-de/</url>
      
        <content type="html"><![CDATA[<h2><span id="什么是循环依懒">什么是循环依懒？</span></h2><p>循环依懒，即依懒形成了一个循环，如：</p><ul><li>A依懒B，B依懒A</li><li>A依懒B，B依懒C，C依懒A</li></ul><h2><span id="spring-是如何解决的">Spring 是如何解决的</span></h2><p>spring 只能解决单例的，并且属性是非构造方法参数注入（set注入）的循环依懒。原理，就是运用缓存，如 getBean(“a”) 获取 A 的时候，先通过反射调用 A 的无参构造方法，创建 A 的 bean，并放入缓存容器。接着执行属性注入，发现 A 中有个 B 的引用属性，又会调用 getBean(“b”)获取 B 的bean，并放入缓存容器。接着执行属性注入，发现 B 中有个 A 的引用属性，又会调用 getBean(“a”)获取 A 的bean（此时形成循环）。这里有个很重要的点： getBean 的时候，都会先查询缓存容器，看是否已经创建过bean了，如果查询到了，就直接返回了。到这里，A 返回给了 B，B 又返回给 A，至此循环依懒完成了属性注入。</p><p><img src="https://i.loli.net/2020/04/20/KhApxaJrq95sXnO.png" alt="Spring 循环依懒运行时序图.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring 是如何解决循环依懒的？ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring加载AnnotationConfig到IOC容器方法调用时序</title>
      <link href="/2020/04/17/spring-jia-zai-annotation-dao-ioc-rong-qi/"/>
      <url>/2020/04/17/spring-jia-zai-annotation-dao-ioc-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring加载-annotationconfig-到ioc容器方法调用时序">Spring加载 AnnotationConfig 到IOC容器方法调用时序：</span></h1><p>Spring 4 之后是可以通过配置类来装载 bean 的，只要类上面加了 @Configuration ，即可以将这个类里面定义的bean 等来进行装载，如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Jzhao"</span>,<span class="number">28</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后简单地写个测试方法，通过 AnnotationConfigApplicationContext ，便可以将 MyConfig 中定义的 person 加载到 IOC 容器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Object bean = app.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        String [] beanNames = app.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(Arrays.toString(beanNames));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="annotationconfig-加载到-ioc-运行时序图">AnnotationConfig 加载到 IOC 运行时序图</span></h2><p><img src="https://i.loli.net/2020/04/17/BGKwdfRTcHPMA7y.png" alt="Spring 通过 Annotaton 配置 Class加载 IOC 时序图 _1_.png"></p><p>通过测试代码，我们大概能画出上面这个时序图。大概给它分成三个步骤：加载、注册、刷新。这里和 XML 加载有个很大不同的，就是XML，注册过程是放在刷新方法中的；而 Annotation 的方式，则是先注册 Bean 到 IOC，然后再刷新。</p><h3><span id="加载">加载</span></h3><p>通过 AnnotationConfigApplicationContext(Class… annotatedClasses) 这个构造函数，这个构造函数中只有三个方法，this()、this.register()、this.refresh()。加载，这里面我们主要看下this()</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 AnnotationConfigApplicationContext 构造方法，我们可以看出，AnnotationConfigApplicationContext 里面直接就放了一个 AnnotatedBeanDefinitionReader ，来用将 AnnotationConfig 解析成 BeanDefinition。</p><h3><span id="注册">注册</span></h3><p>this.register() 方法中就调用加载步骤创建的AnnotatedBeanDefinitionReader，来进行注册操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的</span></span><br><span class="line"><span class="comment">//refresh()方法刷新容器，触发容器对新注册的Bean的处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>{</span><br><span class="line">   Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  一步一步往下走，我们发现了doRegisterBean，这个真正干活的方法，该方法里面完成了BeanDefinition的创建，将前AnnotaionConfig中定义的属性设置到BeanDefinition，最后注册到IOC容器中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bean定义读取器向容器注册注解Bean定义类</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构</span></span><br><span class="line">   AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">   <span class="comment">//解析注解Bean定义的作用域，若@Scope("prototype")，则Bean为原型类型；</span></span><br><span class="line">   <span class="comment">//若@Scope("singleton")，则Bean为单态类型</span></span><br><span class="line">   ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">   <span class="comment">//为注解Bean定义设置作用域</span></span><br><span class="line">   abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">   <span class="comment">//为注解Bean定义生成Bean名称</span></span><br><span class="line">   String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理注解Bean定义中的通用注解</span></span><br><span class="line">   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">   <span class="comment">//如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。</span></span><br><span class="line">   <span class="comment">//主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解</span></span><br><span class="line">   <span class="comment">//Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称</span></span><br><span class="line">   <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {</span><br><span class="line">         <span class="comment">//如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选</span></span><br><span class="line">         <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) {</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置，</span></span><br><span class="line">         <span class="comment">//则该Bean为预实例化</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) {</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一</span></span><br><span class="line">         <span class="comment">//个autowiring自动依赖注入装配限定符，该Bean在进autowiring</span></span><br><span class="line">         <span class="comment">//自动依赖注入装配时，根据名称装配限定符指定的Bean</span></span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) {</span><br><span class="line">      customizer.customize(abd);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据</span></span><br><span class="line">   BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">   <span class="comment">//根据注解Bean定义类中配置的作用域，创建相应的代理对象</span></span><br><span class="line">   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">   <span class="comment">//向IOC容器注册注解Bean类定义对象</span></span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3><span id="刷新">刷新</span></h3><p>通过this.refresh()，调用了父类AnnotationConfigApplicationContext 的 refresh 方法。这里我们就会想到通过 XML 配置文件进行 Bean 装载的时候，也调的这个方法，而这个方法里面才完成了 Bean 的注册。可是通过 AnnotationConfig 的方式，我们上面已经完成过注册了。我们可能会担心这个 refresh 方法，不会再来一次注册吧。下面，我们先到那个关键的 obtainFreshBeanFactory 里来看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>refreshBeanFactory() 方法是委派给子类去实现的，这里我们发现，有两个子类：AbstractRefreshableApplicationContext、GenericApplicationContext 实现了这个方法：</p><p><img src="https://i.loli.net/2020/04/17/smD4HS8Cvb7QqtJ.jpg" alt="111.jpg"></p><p>AbstractRefreshableApplicationContext 我们知道，加载XML到IOC容器，就是用的它。而它的refreshBeanFactory 方法中，可以看出，一定会再创建一个IOC容器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">   <span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//创建IOC容器</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplavyName(), ex);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么剩下的，就是 GenericApplicationContext ，我们再回去看看 AnnotationConfigApplicationContext 正好也是继承了 GenericApplicationContext ：</p><p><img src="https://i.loli.net/2020/04/17/ebC3zcFd2mRDrjO.jpg" alt="222.jpg"></p><p>回到 GenericApplicationContext 的 refreshBeanFactory 方法，仅仅只是给IOC容器设置了一个序列ID：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws IllegalStateException {</span><br><span class="line">   if (!this.refreshed.compareAndSet(false, true)) {</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">            "GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once");</span><br><span class="line">   }</span><br><span class="line">   this.beanFactory.setSerializationId(getId());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，IOC容器刷新成功。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring加载AnnotationConfig到IOC容器方法调用时序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring加载XML配置到IOC容器方法调用时序</title>
      <link href="/2020/04/14/spring-jia-zai-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/"/>
      <url>/2020/04/14/spring-jia-zai-xml-pei-zhi-dao-ioc-rong-qi-fang-fa-diao-yong-shi-xu/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-加载-xml-配置到ioc容器-方法调用时序">Spring 加载 XML 配置到IOC容器 方法调用时序：</span></h2><a id="more"></a><blockquote><p>HttpServletBean.init()</p><blockquote><p>FrameworkServlet.initServletBean() –&gt; initWebApplicationContext() –&gt; createWebApplicationContext() –&gt; configureAndRefreshWebApplicationContext()</p><blockquote><p>AbstractApplicationContext.refresh() –&gt; obtainFreshBeanFactory ()</p><blockquote><p>AbstractRefreshableApplicationContext.refreshBeanFactory()</p><blockquote><p>XmlWebApplicationContext.loadBeanDefinitions() –&gt; loadBeanDefinitions()</p><blockquote><p>XmlBeanDefinitionReader.loadBeanDefinitions() –&gt; doLoadBeanDefinitions() –&gt; registerBeanDefinitions()</p><blockquote><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions() –&gt; doRegisterBeanDefinitions() –&gt; parseBeanDefinitions() –&gt; parseDefaultElement()</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后的 parseDefaultElement 使用策略模式，解析具体的element。</p><h2><span id="ioc运行时序图">IOC运行时序图</span></h2><p><img src="https://i.loli.net/2020/04/16/wZSCUMEqoas8Kz7.png" alt="Spring 5 IOC运行时序图.png"></p><p> spring 的IOC初始化过程，还是比较复杂的。里面比较重点的是IOC容器（BeanFactory）对象的在初始化过程中的传递：</p><ul><li>首先会在 AbstractRefreshableApplicationContext .refreshBeanFactory() 方法中调用createBeanFactory（）完成 IOC容器创建，并通 <code>this.beanFactory = beanFactory;</code>完成将IOC设置到ApplicattionContext 上下文中。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"><span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//创建IOC容器</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接着通过 loadBeanDefinitions 方法，将 beanFactory 传递到 AbstractXmlApplicationContext 中，AbstractXmlApplicationContext 反手就创建了 XmlBeanDefinitionReader 对象，并将 beanFactory 给了它：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br></pre></td></tr></tbody></table></figure><ul><li>继续往下，XmlBeanDefinitionReader 按管了配置文件解析，但它并不是真正干活的对象，而是通过自身属性 documentReaderClass 指定的 Class：DefaultBeanDefinitionDocumentReader ,来创建了一个真正解析XML文件的委派对象：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建BeanDefinitionDocumentReader对象，解析Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> BeanDefinitionDocumentReader<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">BeanUtils</span>.<span class="title">instantiateClass</span>(<span class="title">this</span>.<span class="title">documentReaderClass</span>))</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建后 BeanDefinitionDocumentReader 对象后，XmlBeanDefinitionReader  又将自身注册成 BeanDefinitionDocumentReader 的 readerContext  属性中：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this 参数将 XmlBeanDefinitionReader 传给了 XmlReaderContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">         <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>{</span><br><span class="line">   <span class="comment">//获得XML描述符</span></span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   <span class="comment">//获得Document的根元素</span></span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后通 getReaderContext().getRegistry() 获取到 BeanFactory ,将 bdHolder 中包装 BeanDefinition 注册到BeanFactory 的 IOC 容器Map中：beanDefinitionMap</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向IOC容器注册BeanDefinition（这里的 registry 即是刚开始解析时创建的IOC容器DefaultListableBeanFactory ）</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring加载XML配置到IOC容器方法调用时序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5注解编程基础组件介绍</title>
      <link href="/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/"/>
      <url>/2020/04/13/spring5-zhu-jie-bian-cheng-ji-chu-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-配置组件">1、配置组件</span></h2><a id="more"></a><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>把一个类作为一个 IoC 容器，它的某个方法头上如果注册了 @Bean,就会作为这个 Spring 容器中的 Bean。</td></tr><tr><td>@ComponentScan</td><td>在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下的所有的配置类，相当于之前的&lt;context:component-scan&gt;</td></tr><tr><td>@Scope</td><td>用于指定scope作用域的（用在类上）</td></tr><tr><td>@Lazy</td><td>表示延时初始化</td></tr><tr><td>@Conditional</td><td>Spring4开始提供，它的作用是按照一定的条件进行判断，满足条件给容器注册Bean</td></tr><tr><td>@Import</td><td>导入外部资源</td></tr><tr><td>生命周期控制</td><td>@PostConstruct用于指定初始化方法（用在方法上）<br>@PreDestory用于指定销毁方法（用在方法上）<br>@DependsOn:定义Bean初始化及销毁时的顺序</td></tr></tbody></table><h2><span id="赋值自动装配组件">赋值（自动装配）组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</td></tr><tr><td>@Service</td><td>用于标注业务层组件</td></tr><tr><td>@Controller</td><td>用于标注控制层组件</td></tr><tr><td>@Repository</td><td>用于标注数据访问组件，即DAO组件。</td></tr><tr><td>@Value</td><td>普通数据类型赋值</td></tr><tr><td>@Autowired</td><td>默认按类型装配，如果我们想按名称装配，可以结合@Qualifier注解一起使用</td></tr><tr><td>@PropertySource</td><td>读取配置文件赋值</td></tr><tr><td>@Qualifier</td><td>如存在多个实例配合使用</td></tr><tr><td>@Primary</td><td>自动装配时当出现了多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</td></tr><tr><td>@Resource</td><td>默认按名称装配，当找不到与名称匹配的bean才会按类型装配</td></tr></tbody></table><h2><span id="织入组件">织入组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>ApplicationContextAware</td><td>可以通过这个上下文环境对象得到Spring容器中的Bean</td></tr><tr><td>BeanDefinitionRegistryPostProcessor</td><td>BeanDefinitionRegistryPostProcessor实现了BeanFactoryPostProcessor接口，是Spring框架的BeanDefinitionRegistry的后外理器，用来注册额外的BeanDefinition</td></tr></tbody></table><h2><span id="切面组件">切面组件</span></h2><table><thead><tr><th>注解名称</th><th>说明</th></tr></thead><tbody><tr><td>@EnableTransactionManagement</td><td>添加对事务管理的支持</td></tr><tr><td>@Ttranscational</td><td>配置声明式事务信息</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring5注解编程基础组件介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码学习</title>
      <link href="/2020/04/08/spring-yuan-ma-xue-xi/"/>
      <url>/2020/04/08/spring-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-spring源码学习">咕泡学院-Spring源码学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91Spring%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E4%B8%8ESpring%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.pdf" target="_blank" rel="noopener">Spring前世今生与Spring编程思想</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A8300%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E5%88%9D%E4%BD%93%E9%AA%8CSpring+V1.0%E7%89%88%E6%9C%AC.pdf" target="_blank" rel="noopener">用300行代码手写初体验Spring+V1.0版本</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/Sping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%A830%E4%B8%AA%E7%B1%BB%E6%89%8B%E5%86%99Spring+V2.0%E7%89%88%E6%9C%AC%E4%B9%8B%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1IOC%E4%B8%8EDI.pdf" target="_blank" rel="noopener">用30个类手写Spring+V2.0版本之顶层设计IOC与DI</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> Spring源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习</title>
      <link href="/2020/04/07/she-ji-mo-shi-xue-xi/"/>
      <url>/2020/04/07/she-ji-mo-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2><span id="咕泡学院-设计模式学习">咕泡学院-设计模式学习</span></h2><a id="more"></a><ul><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/01_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88%E5%8F%8A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">设计模式总览及工厂模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/02_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">单例模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/03_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">原型模式与建造者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/04_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">深度分析代理模式</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/05_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">门面模式与装饰器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/06_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">享元模式与组合模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/07_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">适配器模式与桥接模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/08_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">委派模式与模板方法模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/09_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">策略模式与责任链模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/10_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">迭代器模式与命令模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/11_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">状态模式与备忘录模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/12_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">中介者模式与解释器模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/13_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">观察者模式与访问者模式详解</a></li><li><a href="https://gitee.com/zhao451966/blog/raw/hexo/pdf/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/14_%E3%80%90%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94.pdf" target="_blank" rel="noopener">各设计模式总结与对比</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 咕泡学院 </category>
          
          <category> 设计模式学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM升华篇</title>
      <link href="/2020/04/07/jvm-sheng-hua-pian/"/>
      <url>/2020/04/07/jvm-sheng-hua-pian/</url>
      
        <content type="html"><![CDATA[<h1><span id="garbage-collect垃圾回收">Garbage Collect(垃圾回收)</span></h1><a id="more"></a><h2><span id="何为垃圾">何为垃圾：</span></h2><h3><span id="如何确定一个对象是垃圾">如何确定一个对象是垃圾？</span></h3><ol><li><p>引用计数法：</p><p>对于对象而言，如果程序中没有任何对象引用它，它就是垃圾。</p><p>弊端：会存在循环引用，A引用B，B又引用A。而如果此时，A,B都没有被其他对象引用，A,B也是垃圾，但如果用引用计数法，则无法判断它们是垃圾。</p></li><li><p>可达性分析：</p><p>通过GC Root对象，开始向下寻找，看某个对象是否可达  。这里的GC Root (上帝视角），个人理解就是引用的根节点对象，就像一个菜单树一样，通过根节点，就可以向下找到所有的子节点。</p><blockquote><p>什么样的对象可以是GC Root？</p><ul><li>虚拟机栈中的本地变量表</li><li>static成员</li><li>常量引用</li><li>本地方法栈中的变量</li><li>类加载器</li><li>Thread 等</li></ul></blockquote></li></ol><h2><span id="垃圾回收算法">垃圾回收算法：</span></h2><h3><span id="标记-清除mark-sweep">标记-清除（Mark-Sweep）</span></h3><ul><li><p>标记</p><p>找出内存中需要回收的对象，并把它们标记出来</p><blockquote><p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p></li></ul><ul><li><p>清除</p><p>清除掉被标记需要回收的对象，释放出对应的内存空间</p><p><img src="https://i.loli.net/2020/04/08/dIe72hczMiu4r8o.jpg" alt="QQ截图20200408093244.jpg"></p><p>缺点</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span><br><span class="line">1.标记和清除两个过程都比较耗时，效率不高</span><br><span class="line">2.会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span><br></pre></td></tr></tbody></table></figure></li></ul><h3><span id="复制copying">复制（Copying）</span></h3><p>将内存划分成两块相等的区域，每次只使用其中一块，如下图所示：</p><p><img src="https://i.loli.net/2020/04/08/Qsa1dX378V6C2H9.jpg" alt="QQ截图20200408093314.jpg"></p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次性清除掉。</p><p><img src="https://i.loli.net/2020/04/08/HZnAu4pEP6VUSXc.jpg" alt="QQ截图20200408093333.jpg"></p><p>缺点：空间利用率降低。</p><h3><span id="标记-整理mark-compact">标记-整理（Mark-Compact）</span></h3><p>标记过程仍然与“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/V1hKBMo8OSpwiN4.jpg" alt="QQ截图20200408093356.jpg"></p><p>让所有存活的对象都向一端移动，清理掉边界以外的内存。</p><p><img src="https://i.loli.net/2020/04/08/JKIWv6TCErfPaSj.jpg" alt="QQ截图20200408093407.jpg"></p><h2><span id="分代收集算法">分代收集算法</span></h2><blockquote><p>既然上面介绍了3种垃圾收集算法，那么在堆内存中到底用哪一个呢？</p></blockquote><p>Young区：复制算法（对象在被分配之后，可能生命周期比较短，Young区复制效率比较高）</p><p>Old区：标记-清除、标记-整理（Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理）</p><h2><span id="垃圾收集器">垃圾收集器</span></h2><blockquote><p>如果说收集器算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，说白了就是落地。</p></blockquote><p><img src="https://i.loli.net/2020/04/08/hlEaNArspbQiPUM.jpg" alt="QQ截图20200408093426.jpg"></p><h3><span id="serial收集器">Serial收集器</span></h3><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。</p><p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：简单高效，拥有很高的单线程收集效率</span><br><span class="line">缺点：收集过程需要暂停所有线程</span><br><span class="line">算法：复制算法</span><br><span class="line">适用范围：新生代</span><br><span class="line">应用：Client模式下的默认新生代收集器</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/f4d6lO7IGPnowYU.jpg" alt="QQ截图20200408093449.jpg"></p><h3><span id="parnew收集器">ParNew收集器</span></h3><p>可以把这个收集器理解为Serial收集器的多线程版本。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：在多CPU时，比Serial效率高。</span><br><span class="line">缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。</span><br><span class="line">算法：复制算法</span><br><span class="line">适用范围：新生代</span><br><span class="line">应用：运行在Server模式下的虚拟机中首选的新生代收集器</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/bExoILRW47shVpH.jpg" alt="QQ截图20200408093515.jpg"></p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是ParallelScavenge更关注<strong><em>系统的吞吐量</em></strong>。</p><blockquote><p>吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）</p><p>比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=（100-1）/100=99%</p><p>若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--XX:MAXGCPuauseMillis控制最大的垃圾收集停顿时间。</span><br><span class="line">--XX:GCTimeRatio直接设置吞吐量的大小。</span><br></pre></td></tr></tbody></table></figure><h3><span id="serial-old收集器">Serial Old收集器</span></h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“标记-整理法”，运行过程和Serial收集器一样。</p><p><img src="https://i.loli.net/2020/04/08/8435ulwcrxMIePT.jpg" alt="QQ截图20200408093528.jpg"></p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”进行垃圾回收。</p><p><strong><em>吞吐量优先</em></strong></p><h3><span id="cms收集器">CMS收集器</span></h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong><em>最短回收停顿时间</em></strong>为目标的收集器。</p><p>采用的是“标记-清除算法”，整个过程分为4步</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.初始标记 CMS initial mark 标记GC Roots能关联到的对象 Stop The World--&gt;速度很快</span><br><span class="line">2.并发标记 CMS concurrent mark 进行GC Roots Tracking</span><br><span class="line">3.重新标记 CMS remark 修改并发标记因用户程序变动的内容Stop The World</span><br><span class="line">4.并发清除 CMS concurrent sweep</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：并发收集、低停顿</span><br><span class="line">缺点：产生大量空间碎片、并发阶段会降低吞吐量</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/rOmbwLZuMiv63jH.jpg" alt="QQ截图20200408093541.jpg"></p><h3><span id="g1收集器">G1收集器</span></h3><p>G1特点</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并行与并发</span><br><span class="line">分代收集（仍然保留了分代的概念）</span><br><span class="line">空间整合（整体上属于“标记-整理”算法，不会导致这僮碎片）</span><br><span class="line">可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p></blockquote><p>工作过程可以分为如下几步</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程</span><br><span class="line">并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行</span><br><span class="line">最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程</span><br><span class="line">筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制度回收计划</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/04/08/4djyBHMPKu8a1f3.jpg" alt="QQ截图20200408093556.jpg"></p><h3><span id="垃圾收集器分类">垃圾收集器分类</span></h3><ul><li>串行收集器–&gt;Serial和Serial Old</li></ul><p>只能有一个垃圾回收线程执行，用户线程暂停。<strong><em>适用于内存比较小的嵌入式设备</em></strong>。</p><ul><li>并行收集器【吞吐量优先】–&gt;Parallel Scavenge、Parallel Old</li></ul><p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<strong><em>适用于科学计算、后台处理等交互场景</em></strong>。</p><ul><li>并发收集器【停顿时间优先】–&gt;CMS、G1</li></ul><p>用户线程和垃圾收集线程同时执行（但并不一 定是并行的，可能是交替执行的），垃圾收集线程在执行的时候不会停顿用户线程的运行。<strong><em>适用于相对时间有要求的场景，比如web</em></strong>。</p><h3><span id="理解吞吐量和停顿时间">理解吞吐量和停顿时间</span></h3><ul><li>停顿时间–&gt;垃圾收集器进行垃圾回收终端应用执行响应的时间</li><li>吞吐量–&gt;运行用户代码时间/ (运行用户代码时间+垃圾收集时间)</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；</span><br><span class="line">高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</span><br></pre></td></tr></tbody></table></figure><p><strong><em>小结</em></strong>：这两个指标也是评价垃圾回收器好坏的标准，其实调优也就是在观察这两个变量。</p><h3><span id="如何选择合适的垃圾收集器">如何选择合适的垃圾收集器</span></h3><p>官网：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></p><ul><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M,使用串行收集器</li><li>如是是单核，并且没有停顿时间要求，使用串行或JVM自己选</li><li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ul><h3><span id="再次理解g1">再次理解G1</span></h3><blockquote><p> JDK 7开始使用，JDK 8非常成熟，JDK 9 默认的增垃圾收集器，适用于新老生代。</p></blockquote><p>判断是否需要使用G1收集器？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.50%以上的堆被存活对象占用</span><br><span class="line">2.对象分配和晋升的速度变化非常大</span><br><span class="line">3.垃圾回收时间比较长</span><br></pre></td></tr></tbody></table></figure><h3><span id="如何开启需要的垃圾收集器">如何开启需要的垃圾收集器</span></h3><ol><li><p>串行</p><p>–XX:+UserSerialGC</p><p>–XX:+UserSerialoldGC</p></li><li><p>并行（吞吐量优先）</p><p>–XX:+UseParallelGC</p><p>–XX:+UseParalleloldGC</p></li><li><p>并发（响应时间优先）</p><p>–XX:+UseConcMarkSweepGC</p><p>–XX:+UseG1GC</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM升华篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Garbage Collect(垃圾回收) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
